# Multiform

Example of Terraform with multiple stacks.

## Dependencies

- Bash 4 or above
- Git 2.32 or above
- GNU Make 3 or above
- Python 3.8 or above
- Terraform 1.x

---

## Usage

Use Make to run the appropriate tasks.

The *info* task provides current settings:

    make info

Use *make clean* to delete all generated files:

    make clean

---

## Design 

1. The core of the design is a set of conventions for Terraform projects. These consist of an *expected directory structure* and a set of *code conventions for Terraform stacks*.
2. The settings for a deployment are inferred from the directory structure and Terraform files. This avoids the need to maintain additional configuration.
3. The Terraform commands are generated by a helper script, which acts as a *command builder*. Each Terraform command is returned to the caller as a string. The caller is then responsible for executing the command. The helper script does not execute commands, and does not manage the environment where code is executed.
4. Each Terraform command that the builder produces executes on a specific Terraform *stack*, which is defined by the *expected directory structure*.

> *This design does not use Terraform workspaces*

## Expected Directory Structure

- Each project has single root directory for Terraform code and configuration
- The project root directory for Terraform is called *terraform/*
- Each stack is a sub-directory under the *terraform/stacks/* directory.

## Code Conventions for a Terraform Stack

- Each stack is a Terraform root module.
- A stack may include Terraform modules.
- Each stack uses two sets of variable files: a *global  configuration* that applies to all instances of all stacks in all environments, and a *stack* configuration that is defined per *environment*.
- Each stack is deployed with an *instance identifier*, so that multiple instances of a stack may be deployed to the same cloud account with the same *environment* definition. This enables various use cases, such as testing, blue-green deployment and disaster recovery.
- By default, the *instance identifier* is an empty string.
- Each stack has a separate Terraform state file per environment and instance identifier
- Each stack should be deployable on any cloud account that can provide the resources that the stack depends on.
- Avoid references to remote Terraform state, so that instances of a stack do not have dependencies on the state of other Terraform deployments

## Terraform Command Builder

- The command builder is currently implemented as a Python 3 script.
- This script is currently a single file to avoid dependency and deployment issues
- The script only uses the Python standard library. It requires no additional packages.
- The license is embedded in the file
- The initial implementation is designed for clarity. It uses a minimal set of the Python language in a functional style.

## Project Dependencies

- The dependencies are selected to avoid introducing any requirements that are not generally accepted and included on systems by default.
- The required versions of software are provided with macOS Monteray (12.5) and above, or any Debian-based Linux distribution.
- The versions of Bash and GNU Make are frozen on macOS due to software licenses, so we must maintain compatibility with Bash 4 and GNU Make 3
- Future iterations may replace the dependencies on Bash and Make.
- There are no direct dependencies on Docker 
- There are no direct dependencies on the AWS CLI

### Make

- The core Makefile contains only essential items and *includes*, so that Make files for components can be handled separately
- The settings in the core Makefile enforce the use of Bash for consistency
- The settings in the core Makefile set the error handling that is supported by the baseline Bash and Make versions
- The settings in the core Makefile enforce one shell per target, rather than one per line
